<div class="card-grid infinite-scroll">
  <div class="card-set {{ additional_class }}">
    {% for element in include.content %}
      <a class="card {{ include.class }}" href="{{ element.url | relative_url }}">
        {% if element.image %}
        <img src="{{ element.image | relative_url }}" alt="{{ element.title }}">
        {% endif %}
        <h3>{{ element.title }}</h3>
        <p>{{ element.text }}</p>
      </a>
    {% endfor %}
  </div>
</div>


  {% if include.infinite %}
<script>
document.addEventListener('DOMContentLoaded', function() {
  const cardGrids = document.querySelectorAll('.card-grid.infinite-scroll');

  cardGrids.forEach(grid => {
    const cardSet = grid.querySelector('.card-set');
    if (!cardSet) return;

    const originals = Array.from(cardSet.children);
    let isInfiniteActive = false;
    let isRepositioning = false;

    function clearClones() {
      // Rimuove tutte le card clonate
      Array.from(cardSet.children).forEach((card, index) => {
        if (index >= originals.length) card.remove();
      });
    }

    function setupInfinite() {
      if (isInfiniteActive) return; // evita setup multipli
      clearClones();

      // Clona le card 2 volte per creare il ciclo infinito
      for (let i = 0; i < 2; i++) {
        originals.forEach(card => cardSet.appendChild(card.cloneNode(true)));
      }

      const originalCount = originals.length;
      const cardWidth = originals[0] ? originals[0].offsetWidth + 32 : 0; // +margin
      const setWidth = cardWidth * originalCount;

      // Imposta lo scroll centrale *dopo il rendering*
      requestAnimationFrame(() => {
        grid.style.scrollBehavior = 'auto';
        grid.scrollLeft = setWidth;
        requestAnimationFrame(() => {
          grid.style.scrollBehavior = 'smooth';
        });
      });

      isInfiniteActive = true;

      const handleScroll = () => {
        if (isRepositioning) return;

        const scrollLeft = grid.scrollLeft;
        const threshold = 50;

        const repositionScroll = (direction) => {
          isRepositioning = true;
          grid.style.scrollBehavior = 'auto';
          grid.style.scrollSnapType = 'none';

          const adjustment = direction === 'right' ? -setWidth : setWidth;
          grid.scrollLeft = scrollLeft + adjustment;

          requestAnimationFrame(() => {
            grid.style.scrollBehavior = 'smooth';
            grid.style.scrollSnapType = 'x mandatory';
            isRepositioning = false;
          });
        };

        if (scrollLeft > setWidth * 2 - threshold) {
          repositionScroll('right');
        } else if (scrollLeft < threshold) {
          repositionScroll('left');
        }
      };

      grid.removeEventListener('scroll', handleScroll);
      grid.addEventListener('scroll', handleScroll, { passive: true });
    }

    function setupDesktop() {
      clearClones();
      originals.forEach(card => card.style.display = '');
      grid.scrollLeft = 0;
      isInfiniteActive = false;
    }

    function handleResponsive() {
      if (window.innerWidth <= 768) {
        setupInfinite();
      } else {
        setupDesktop();
      }
    }

    handleResponsive();
    window.addEventListener('resize', handleResponsive);
  });
});
</script>

{% endif %}

<script>
  document.addEventListener('DOMContentLoaded', function () {
    document.querySelectorAll('.card-set').forEach(cardSet => {
      cardSet.addEventListener('wheel', function (e) {
        // Se non c'è delta verticale, non facciamo niente
        if (e.deltaY === 0) return;

        const atStart = this.scrollLeft === 0;
        const atEnd = this.scrollLeft + this.clientWidth >= this.scrollWidth;

        // debug:
        //console.log(`scrollLeft: ${this.scrollLeft}, scrollWidth: ${this.scrollWidth}, clientWidth: ${this.clientWidth}, atStart: ${atStart}, atEnd: ${atEnd}, deltaY: ${e.deltaY}`);
        
        // Se non siamo né all'inizio né alla fine, oppure se stiamo andando nella direzione "interna"
        if (
          ! (
            (atEnd && e.deltaY > 0) ||   // stai scrollando verso sinistra ma sei già a inizio
          (atStart && e.deltaY < 0)
        )
        ) {    // stai scrollando verso destra ma sei già a fine
          e.preventDefault();
          this.scrollLeft += (e.deltaY) * 10;
          //console.log(`Nuovo scrollLeft: ${this.scrollLeft}`);
        }
        // altrimenti lasciamo che lo scroll vada alla pagina
      }, { passive: false });
    });

  });
</script>